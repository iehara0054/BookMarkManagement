/*
=================================================================================
このファイルの概要
=================================================================================
このファイルは、Ajax通信を使用したお気に入り機能の実装サンプルです。
ユーザーがボタンをクリックすると、サーバーと非同期通信を行い、
ページをリロードせずにお気に入り状態を切り替えることができます。

主な技術要素:
- fetch() API: 従来のXMLHttpRequestよりもシンプルでモダンな非同期通信のインターフェース
  戻り値はPromiseオブジェクトで、async/await構文と組み合わせて使用可能
- JSONデータの送受信: headersで'Content-Type': 'application/json'を指定し、
  bodyにはJSON.stringify()でJavaScriptオブジェクトをJSON文字列に変換して送信
- UIの動的更新: サーバーのレスポンスに基づき、classList.toggle()やtextContentで
  ページ全体をリロードせずにボタンの外観とテキストを切り替え
- エラーハンドリング: try...catch...finallyブロックで通信エラーや処理完了を適切に処理
=================================================================================
*/

/*
追加した内容
ajax_jissou.js に以下のような詳細なコメントを追加しました：
📋 ファイル構成
概要セクション (1-18行目)
このファイル全体の目的と使用している技術要素の説明
HTML構造セクション (20-44行目)
お気に入りボタンのHTML構造
各要素の役割と属性の意味を解説
CSSスタイルセクション (46-74行目)
各CSSプロパティの意味と効果
お気に入り状態による見た目の変化を説明
JavaScript実装セクション (76-222行目)
コードを9つのブロックに分けて詳細に解説：
DOM要素とデータの取得
ボタンクリック時のイベントリスナー設定
二重送信防止処理
サーバーへのAjaxリクエスト送信
レスポンスの検証
レスポンスデータの解析
UIの動的更新
エラーハンドリング
後処理
💡 コメントの特徴
各行の処理内容を具体的に説明
使用しているAPIや関数の役割を明記
なぜそのコードが必要なのか（目的）も記載
初心者でも理解しやすいよう、専門用語にも説明を追加
これで、Ajax通信の仕組みが1行ずつ理解できるようになっています！
*/

/*
=================================================================================
HTML構造
=================================================================================
お気に入りボタンのHTML構造です。

<button id="favorite-button" class="favorite-btn" data-item-id="123">
    ↑ ボタン要素
    - id="favorite-button": JavaScriptからこのボタンを取得するための一意の識別子
    - class="favorite-btn": スタイリング用のCSSクラス
    - data-item-id="123": お気に入り対象のアイテムID（カスタムデータ属性）
                          この値がサーバーに送信されます

    <span class="icon">☆</span>
    ↑ アイコン表示用のspan要素
    - お気に入り未登録時: ☆（白抜き星）
    - お気に入り登録済み: ★（塗りつぶし星）

    <span class="text">お気に入り</span>
    ↑ ボタンのテキスト表示用のspan要素
    - お気に入り未登録時: 「お気に入り」
    - お気に入り登録済み: 「お気に入り済み」
</button>
=================================================================================
*/

/*
=================================================================================
CSSスタイル定義
=================================================================================
お気に入りボタンの見た目を定義するスタイルです。

.favorite-btn {
    padding: 10px 15px;              // ボタン内側の余白（上下10px、左右15px）
    cursor: pointer;                 // マウスカーソルをポインター（指マーク）に変更
    border: 1px solid #ccc;          // 1pxの灰色の境界線
    background-color: #f9f9f9;       // 薄い灰色の背景色（未登録状態）
    transition: color 0.3s, background-color 0.3s;  // 色変化を0.3秒かけてスムーズに
}

.favorite-btn.is-favorited {
    // お気に入り登録済み状態のスタイル
    // 「is-favorited」クラスが追加されたときに適用される
    color: white;                    // テキスト色を白に変更
    background-color: #ff4500;       // 背景色をオレンジ赤に変更（目立つ色）
    border-color: #ff4500;           // 境界線の色も同じオレンジ赤に
}

.favorite-btn.is-favorited .icon {
    // お気に入り登録済み状態のアイコンスタイル
    content: "★";                    // アイコンを塗りつぶし星に変更
                                     // ※実際はJavaScriptのtextContentで変更します
}
=================================================================================
*/

/*
=================================================================================
JavaScript実装部分
=================================================================================
*/

// DOMContentLoadedイベント: HTMLドキュメントの解析が完了し、DOMツリーが構築されたときに発火
// このタイミングでJavaScriptを実行することで、確実にHTML要素にアクセスできます
document.addEventListener('DOMContentLoaded', () => {

    // ========================================
    // 1. DOM要素とデータの取得
    // ========================================

    // getElementById(): IDが'favorite-button'の要素（ボタン）を取得
    const favoriteButton = document.getElementById('favorite-button');

    // getAttribute(): ボタンのdata-item-id属性からアイテムIDを取得
    // カスタムデータ属性はHTML5で追加された機能で、任意のデータを要素に格納できます
    const itemId = favoriteButton.getAttribute('data-item-id');

    // querySelector(): ボタン内のクラス'icon'を持つ最初の要素を取得（星アイコン）
    const iconSpan = favoriteButton.querySelector('.icon');

    // querySelector(): ボタン内のクラス'text'を持つ最初の要素を取得（テキスト部分）
    const textSpan = favoriteButton.querySelector('.text');

    // APIエンドポイントのURL定義
    // 実際の開発では、環境に応じて適切なURLに変更する必要があります
    const apiEndpoint = '/api/toggle-favorite';

    // ========================================
    // 2. ボタンクリック時のイベントリスナー設定
    // ========================================

    // addEventListener(): クリックイベントを監視
    // async キーワード: この関数を非同期関数として定義（awaitが使用可能になる）
    favoriteButton.addEventListener('click', async () => {

        // ========================================
        // 3. 二重送信防止処理
        // ========================================

        // ボタンを無効化して、処理中の二重クリックを防止
        // disabled = true: ボタンがグレーアウトし、クリックできなくなります
        favoriteButton.disabled = true;

        try {
            // ========================================
            // 4. サーバーへのAjaxリクエスト送信
            // ========================================

            // fetch(): モダンなHTTP通信API、Promiseを返す
            // await: Promiseが解決（resolve）されるまで処理を待機
            const response = await fetch(apiEndpoint, {
                method: 'POST',              // HTTPメソッド: POSTでデータを送信
                headers: {
                    // Content-Type: 送信するデータの形式をサーバーに通知
                    // application/json: JSON形式でデータを送信することを宣言
                    'Content-Type': 'application/json',
                },
                // body: リクエストボディ（送信するデータ）
                // JSON.stringify(): JavaScriptオブジェクトをJSON文字列に変換
                // { itemId: itemId } を送信（どのアイテムのお気に入りを切り替えるか）
                body: JSON.stringify({ itemId: itemId })
            });

            // ========================================
            // 5. レスポンスの検証
            // ========================================

            // response.ok: HTTPステータスコードが200-299の範囲ならtrue
            // !response.ok: ステータスコードが200-299以外（エラー）ならtrue
            if (!response.ok) {
                // throw new Error(): エラーを発生させ、catchブロックへ処理を移す
                throw new Error('ネットワークレスポンスが不正です');
            }

            // ========================================
            // 6. レスポンスデータの解析
            // ========================================

            // response.json(): レスポンスボディをJSONとして解析
            // await: JSON解析が完了するまで待機
            // 解析結果はJavaScriptオブジェクトとして取得されます
            const data = await response.json();

            // ========================================
            // 7. UIの動的更新（お気に入り状態に応じた表示切り替え）
            // ========================================

            // サーバーからの結果を確認
            // 例: サーバーは { "favorited": true } または { "favorited": false } を返す
            if (data.favorited) {
                // ========== お気に入り登録済みの場合 ==========

                // classList.add(): 'is-favorited'クラスを追加
                // これによりCSSの.favorite-btn.is-favoritedスタイルが適用されます
                favoriteButton.classList.add('is-favorited');

                // textContent: 要素のテキスト内容を設定
                // アイコンを塗りつぶし星（★）に変更
                iconSpan.textContent = '★';

                // ボタンのテキストを「お気に入り済み」に変更
                textSpan.textContent = 'お気に入り済み';
            } else {
                // ========== お気に入り未登録の場合 ==========

                // classList.remove(): 'is-favorited'クラスを削除
                // 通常の.favorite-btnスタイルに戻ります
                favoriteButton.classList.remove('is-favorited');

                // アイコンを白抜き星（☆）に変更
                iconSpan.textContent = '☆';

                // ボタンのテキストを「お気に入り」に変更
                textSpan.textContent = 'お気に入り';
            }

        } catch (error) {
            // ========================================
            // 8. エラーハンドリング
            // ========================================

            // catch: tryブロック内でエラーが発生した場合に実行される
            // ネットワークエラー、サーバーエラー、JSON解析エラーなどをキャッチ

            // console.error(): エラーメッセージをブラウザのコンソールに出力
            // 開発者がデバッグ時に確認できます
            console.error('お気に入り機能でエラーが発生しました:', error);

            // alert(): ユーザーにエラーメッセージを表示
            // 実際のアプリケーションでは、よりユーザーフレンドリーなエラー表示を実装します
            alert('お気に入り状態の更新に失敗しました。');

        } finally {
            // ========================================
            // 9. 後処理（成功・失敗に関わらず必ず実行）
            // ========================================

            // finally: try/catchの結果に関わらず必ず実行されるブロック
            // ボタンを再度有効化し、次のクリックを受け付けられるようにします
            favoriteButton.disabled = false;
        }
    });
});


